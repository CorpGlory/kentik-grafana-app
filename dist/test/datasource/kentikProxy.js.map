{"version":3,"sources":["../../../src/datasource/kentikProxy.js"],"names":["getUTCTimestamp","ts","Date","getTime","getTimezoneOffset","getHash","queryObj","query","cloneDeep","starting_time","ending_time","JSON","stringify","getMaxRefreshInterval","interval","parse","duration","KentikProxy","backendSrv","kentikAPISrv","kentikAPI","cache","cacheUpdateInterval","requestCachingIntervals","getDevices","bind","formatQuery","cached_query","hash","shouldInvoke","invokeQuery","then","timestamp","result","console","log","Promise","resolve","kentik_query","query_range","cache_starting_time","cache_ending_time","cached_query_range","max_refresh_interval","Math","abs","field","value","getFieldValues","module","service"],"mappings":"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","file":"kentikProxy.js","sourcesContent":["import angular from 'angular';\nimport _ from 'lodash';\nimport moment from 'moment';\nimport './kentikAPI';\n\nfunction getUTCTimestamp() {\n  let ts = new Date();\n  return ts.getTime() + ts.getTimezoneOffset() * 60 * 1000;\n}\n\n// Get hash of Kentik query\nfunction getHash(queryObj) {\n  let query = _.cloneDeep(queryObj);\n  query.starting_time = null;\n  query.ending_time = null;\n  return JSON.stringify(query);\n}\n\n// Prevent too frequent queries\nfunction getMaxRefreshInterval(query) {\n  let interval = Date.parse(query.ending_time) - Date.parse(query.starting_time);\n  if (interval > moment.duration(1, 'months')) {\n    return 60 * 60 * 1000; // 1 hour\n  } else if (interval > moment.duration(1, 'day')) {\n    return 15 * 60 * 1000; // 15 min\n  } else {\n    return 5 * 60 * 1000; // 5 min\n  }\n}\n\nclass KentikProxy {\n  constructor(backendSrv, kentikAPISrv) {\n    this.kentikAPI = kentikAPISrv;\n    this.cache = {};\n    this.cacheUpdateInterval = 5 * 60 * 1000; // 5 min by default\n    this.requestCachingIntervals = {\n      '1d': 0\n    };\n\n    this.getDevices = this.kentikAPI.getDevices.bind(this.kentikAPI);\n    this.formatQuery = this.kentikAPI.formatQuery.bind(this.kentikAPI);\n  }\n\n  invokeQuery(query) {\n    let cached_query = _.cloneDeep(query);\n    let hash = getHash(cached_query);\n\n    if (this.shouldInvoke(query)) {\n      // Invoke query\n      return this.kentikAPI.invokeQuery(query)\n      .then(result => {\n        let timestamp = getUTCTimestamp();\n\n        this.cache[hash] = {\n          timestamp: timestamp,\n          query: cached_query,\n          result: result\n        };\n        console.log('Invoke Kentik query');\n        return result;\n      });\n    } else {\n      // Get from cache\n      console.log('Get result from cache');\n      return Promise.resolve(this.cache[hash].result);\n    }\n  }\n\n  // Decide, is query shold be invoked or get data from cahce?\n  shouldInvoke(query) {\n    let kentik_query = query;\n    let hash = getHash(kentik_query);\n    let timestamp = getUTCTimestamp();\n\n    let starting_time = Date.parse(kentik_query.starting_time);\n    let ending_time = Date.parse(kentik_query.ending_time);\n    let query_range = ending_time - starting_time;\n\n    let cache_starting_time = this.cache[hash] ? Date.parse(this.cache[hash].query.starting_time) : null;\n    let cache_ending_time = this.cache[hash] ? Date.parse(this.cache[hash].query.ending_time) : null;\n    let cached_query_range = cache_ending_time - cache_starting_time;\n\n    let max_refresh_interval = getMaxRefreshInterval(kentik_query);\n\n    return (\n      !this.cache[hash] ||\n      timestamp - ending_time > max_refresh_interval ||\n      (this.cache[hash] && (\n        timestamp - cache_ending_time > max_refresh_interval ||\n        starting_time < cache_starting_time ||\n        Math.abs(query_range - cached_query_range) > 60 * 1000 // is time range changed?\n      ))\n    );\n  }\n\n  getFieldValues(field) {\n    let ts = getUTCTimestamp();\n    if (this.cache[field] && ts - this.cache[field].ts < this.cacheUpdateInterval) {\n      return Promise.resolve(this.cache[field].value);\n    } else {\n      return this.kentikAPI.getFieldValues(field)\n      .then(result => {\n        ts = getUTCTimestamp();\n        this.cache[field] = {\n          ts: ts,\n          value: result\n        };\n\n        return result;\n      });\n    }\n  }\n}\n\nangular\n  .module('grafana.services')\n  .service('kentikProxySrv', KentikProxy);\n"]}